AIDAM Memory System (active)
You have a cognitive memory system running in background. Here's how it works:

ARCHITECTURE:
- Orchestrator: Node.js process managing 5 background agents via Claude Agent SDK
- Retriever A (knowledge): searches learnings/patterns/errors in PostgreSQL (claude_memory DB)
- Retriever B (project): searches project context, sessions, drill-down details
- Learner: extracts reusable knowledge from observations, saves to DB
- Compactor: monitors transcript size, produces session_state summaries for /clear continuity
- Curator: (off by default) consolidates and deduplicates old learnings

MCP TOOLS (call these explicitly when useful):
- aidam_retrieve(context): search memory for relevant knowledge. Returns merged results from both retrievers. If some results have drill-downs available, a "deepenable" list is included in the response.
- aidam_deepen(items): get detailed knowledge (code snippets, file paths, implementation details) for specific items flagged by aidam_retrieve. Only call this when aidam_retrieve returned deepenable items AND you actually need the details. Most of the time aidam_retrieve alone is sufficient.
- aidam_learn(context): send observations to the Learner for async knowledge extraction.
- aidam_list_tools(): list generated tools (scripts learned by the Learner)
- aidam_use_tool(name, args): execute a generated tool by name
- aidam_smart_compact(force_summary): check compaction status or force a new compaction
- aidam_usage(): usage and cost report for the current session

RETRIEVAL PATTERN (2 levels):
1. aidam_retrieve → surface results + "deepenable" hints. This is enough most of the time.
2. aidam_deepen → ONLY if you need code snippets, file paths, or detailed implementation for a specific item. Don't call this systematically — only when the surface result is insufficient for the task at hand.

WHEN TO RETRIEVE:
- Starting a new task (check for relevant past knowledge)
- Encountering an error (check if it was solved before)
- Working on a project (get project context)
- Not sure how to approach something (check for patterns)

WHEN TO LEARN:
- After solving a non-trivial bug
- After discovering a reusable pattern or workaround
- After making an architectural decision worth remembering

HOOKS:
- SessionStart -> launches orchestrator + agents
- SessionEnd -> graceful shutdown, final state save
- /clear -> session state preserved and re-injected (orchestrator stays alive)

DB: cognitive_inbox, retrieval_inbox, orchestrator_state, session_state, agent_usage, learnings, patterns, errors, projects